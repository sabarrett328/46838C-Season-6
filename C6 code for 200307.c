#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, in1,    expBatt,        sensorAnalog)
#pragma config(Sensor, in3,    liftpos,        sensorPotentiometer)
#pragma config(Sensor, in4,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderR,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  lifthigh,       sensorTouch)
#pragma config(Sensor, dgtl4,  driverskill,    sensorDigitalIn)
#pragma config(Sensor, dgtl5,  leftsense,      sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  rightsense,     sensorSONAR_mm)
#pragma config(Sensor, dgtl9,  frontsense,     sensorSONAR_mm)
#pragma config(Sensor, dgtl11, encoderL,       sensorQuadEncoder)
#pragma config(Motor,  port2,           driveRF,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           driveRR,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           liftLL,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftLR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftUL,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftUR,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveLF,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveLR,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          grip,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*               Description: Competition code for VEX EDR                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/////////////////////////////////////////////////////////////////////////////
// Rebel Alliance Robotics and Team 46838C Present
//
// Charlie 6.0 in * Tower Takeover *
//
// The 2019-2020 Vex RC Competition Season
//
// Coming soon to an event near you!
////////////////////////////////////////////////////////////////////////////

//*************************************************************************
//                                                                        *
//                          Global Variables                              *
//                                                                        *
//*************************************************************************
float fudge = 1; //real world fudge factor for wheel circumference//
float dia = 4; //actual measured diameter of omni wheel//
float cir = dia*PI/fudge; //calc distance around wheel//
int decel = 150;// number of encoder counts to slow down when driving by distance
float turnfactor = 65;//scaling factor to turn encoder counts to degrees
int pause = 100; //pause for 1/10 of a second
int autonProgram = 99; //tracker for which auton to run.  99=default.  if not changed sounds beeps
int X2 = 0, Y1 = 0, X1 = 0, threshold = 18; //deadzone variable to control joystick drift for driver control
int maxspeed = 127;// maximium motor speed
float drivescale = 0.3;// scaling speed for drive slowdown
int field = 2200 ;//potentiometer value for lift at field level
int offgoal = 2350;//potentiometer value for lift going into corner
int offfield = 2500;//potentiometer value for lift just above field
int lowcup = 3070 ;// potentiometer value for lift at low cup
int midcup = 3270;// potentiometer value for lift at middle cup
int highcup = 4000;// potentiometer value for lift at high cup
float drive_P = .25;//Proportional constant for drive base
float lift_P = 0.25;// Proportional constant for lift PID math
float lift_I = 0.0;// Integral constant for lift PID math
float liftIlimit = 200.0;// limit for integral value use
float lift_D = 0.3;// Derivative constant for lift PID math
float liftrequest;// requested value for lift to go to
int liftbias = 25;// base value for lift to hold
int manual = 0;// tracking variable to determine if we were in manual lift or auto lift
int gripped = 90;// motor value for max clamped on gripper motors
int skilltrack = 0;// tracking variable for driver skills programing
int matchtime = 105000;//total time for a match
int buzz1 = 15000;//15 seconds from the end of match for 1st buzz
int buzz2 = 5000;//5 seconds from the end of match for 2nd buzz



// end of global variables

///////////////////////////////////////////////////////////////////////////
//                                                                        /
//                          Robot Basic Functions                         /
//                functions used for Autonomous routines                  /
//                                                                        /
///////////////////////////////////////////////////////////////////////////

/////////////////////////////////
//
//   DRIVE FOR A DISTANCE
//  using both encoders
//    function
//
/////////////////////////////////

void drive2(int speedlr,float distlr)
{
	float target = (360/cir)*distlr;//calculate target encoder counts//
	SensorValue[encoderL] = 0;//reset encoder count to zero//
	SensorValue[encoderR] = 0;//reset encoder count to zero//
	if (speedlr > 90)//limit max speed so error correction can work
	{
		speedlr = 90;
	}

	//set up variables for driving straight
	float error = 0;
	float adjust = 0;
	float leftpwr = 0;
	float rightpwr = 0;

	if (distlr > 0)// if distance is positive
	{
		while(SensorValue[encoderL] < target)
		{
			error = SensorValue[encoderL]-SensorValue[encoderR];//calculate encoder errors
			adjust = drive_P*error;// calculate amount to adjust motor power
			rightpwr = speedlr+adjust;
			leftpwr = speedlr-adjust;
			motor[driveLF] = motor[driveLR] = leftpwr;
			motor[driveRF] = motor[driveRR] = rightpwr;
			wait1Msec(25);
		}
		//reverse brake
		motor[driveLF] = motor[driveLR] = -50;
		motor[driveRF] = motor[driveRR] = -50;
		wait1Msec(pause);
		//stop motors
		motor[driveLF] = motor[driveLR] = 0;
		motor[driveRF] = motor[driveRR] = 0;
	}
	else// distlr is negative
	{
		while(SensorValue[encoderL] > target)
		{
			error = SensorValue[encoderR]-SensorValue[encoderL];//calculate encoder errors
			adjust = drive_P*error;// calculate amount to adjust motor power
			rightpwr = speedlr+adjust;
			leftpwr = speedlr-adjust;
			motor[driveLF] = motor[driveLR] = -leftpwr;
			motor[driveRF] = motor[driveRR] = -rightpwr;
			wait1Msec(25);
		}
		//reverse brake
		motor[driveLF] = motor[driveLR] = 50;
		motor[driveRF] = motor[driveRR] = 50;
		wait1Msec(pause);
		//stop motors
		motor[driveLF] = motor[driveLR] = 0;
		motor[driveRF] = motor[driveRR] = 0;
	}
}//end drive2 function

/////////////////////////////////
//
//   DRIVE FOR A DISTANCE function
//
/////////////////////////////////

void drive(int speed,float dist) //function for driving a given distance at a given speed/
{
	float target = (360/cir)*dist; //calculate target encoder counts//

	SensorValue[encoderL] = 0; //reset encoder count to zero//

	//while encoder is less than decel dist(counts), run full speed
	if (dist > 0)
	{
		while (SensorValue[encoderL] < target-decel)
		{
			motor[driveLF] = speed;
			motor[driveRF] = speed;
			motor[driveLR] = speed;
			motor[driveRR] = speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] < target)
		{
			motor[driveLF] = 50;
			motor[driveRF] = 50;
			motor[driveLR] = 50;
			motor[driveRR] = 50;
		}

		// briefly reverse motors to brake
		motor[driveLF] = -60;
		motor[driveRF] = -60;
		motor[driveLR] = -60;
		motor[driveRR] = -60;
		wait1Msec(pause);

		//turn off motors
		motor[driveLF] = 0;
		motor[driveRF] = 0;
		motor[driveLR] = 0;
		motor[driveRR] = 0;
	}
	else
	{
		while (SensorValue[encoderL] > target+decel)
		{
			motor[driveLF] = -speed;
			motor[driveRF] = -speed;
			motor[driveLR] = -speed;
			motor[driveRR] = -speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] > target)
		{
			motor[driveLF] = -50;
			motor[driveRF] = -50;
			motor[driveLR] = -50;
			motor[driveRR] = -50;
		}
		// briefly reverse motors to brake
		motor[driveLF] = 60;
		motor[driveRF] = 60;
		motor[driveLR] = 60;
		motor[driveRR] = 60;
		wait1Msec(pause);

		//turn off motors
		motor[driveLF] = 0;
		motor[driveRF] = 0;
		motor[driveLR] = 0;
		motor[driveRR] = 0;
	}
}// end drive for a distance function


/////////////////////////////////
//
//   DRIVE FOR A TIME function
//
/////////////////////////////////
void drivetime(int speed, int timems) // time based drive
{
	motor[driveLF] = speed;
	motor[driveRF] = speed;
	motor[driveLR] = speed;
	motor[driveRR] = speed;

	wait1Msec(timems);

	motor[driveLF] = 0;
	motor[driveRF] = 0;
	motor[driveLR] = 0;
	motor[driveRR] = 0;

}// end drive for time function


/////////////////////////////////
//
//   STRAFE FOR A DISTANCE function
//   left is positive
//   right is negavive
//
/////////////////////////////////
void strafe(int speed,float dist) //function for strafing a given distance at a given speed//
{
	float target = (360/cir)*dist; //calculate target encoder counts//

	SensorValue[encoderL] = 0; //reset encoder count to zero//


	//while encoder is less than decel dist(counts), run full speed
	if (dist > 0)// left move
	{
		while (SensorValue[encoderL] < target-decel)
		{
			motor[driveLF] = -speed;
			motor[driveRF] = speed;
			motor[driveLR] = speed;
			motor[driveRR] = -speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] < target)
		{
			motor[driveLF] = -70;
			motor[driveLR] = 70;
			motor[driveRF] = 70;
			motor[driveRR] = -70;
		}

		// briefly reverse motors to brake
		motor[driveLF] = 60;
		motor[driveLR] = -60;
		motor[driveRF] = -60;
		motor[driveRR] = 60;
		wait1Msec(pause);

		//turn off motors
		motor[driveLF] = 0;
		motor[driveLR] = 0;
		motor[driveRF] = 0;
		motor[driveRR] = 0;
	}
	else// right move
	{
		while (SensorValue[encoderL] > target+decel)
		{
			motor[driveLF] = speed;
			motor[driveLR] = -speed;
			motor[driveRF] = -speed;
			motor[driveRR] = speed;
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] > target)
		{
			motor[driveLF] = 70;
			motor[driveLR] = -70;
			motor[driveRF] = -70;
			motor[driveRR] = 70;
		}
		// briefly reverse motors to brake
		motor[driveLF] = -60;
		motor[driveLR] = 60;
		motor[driveRF] = 60;
		motor[driveRR] = -60;
		wait1Msec(pause);

		//turn off motors
		motor[driveLF] = 0;
		motor[driveLR] = 0;
		motor[driveRF] = 0;
		motor[driveRR] = 0;
	}

}// end strafe for a distance function



/////////////////////////////////
//
//   STRAFE FOR A time function
//   left is positive
//   right is negavive
//
/////////////////////////////////

void strafetime(int speed,int timems) //function for strafing for a given time//
{
	motor[driveLF] = -speed;
	motor[driveLR] = speed;
	motor[driveRF] = speed;
	motor[driveRR] = -speed;

	wait1Msec(timems);

	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end strafe for time function


/////////////////////////////////////
//
//   gyroturn - turn by gyroscope
//
/////////////////////////////////////

void gyroturn(int speed, float angle)
{
	int target = (angle * 10) + SensorValue[gyro];
	int error = 10;
	// clockwise turn
	if(SensorValue[gyro] < target - 100)
	{
		motor[driveLR] = motor[driveLF] = speed;
		motor[driveRR] = motor[driveRF] = -speed;

		//loop to move the robot more slowly to its goal, also setting up a range
		//for the amount of acceptable error in the system
		while(SensorValue[gyro] < (target - error) || abs(SensorValue[gyro]) > (target + error))
		{
			if(SensorValue[gyro] > target)
			{
				motor[driveLR] = motor[driveLF] = -45;
				motor[driveRR] = motor[driveRF] = 45;
			}
			else
			{
				motor[driveLR] = motor[driveLF] = 45;
				motor[driveRR] = motor[driveRF] = -45;
			}
		}// end while
		//Stop
		motor[driveLR] = motor[driveLF] = 0;
		motor[driveRR] = motor[driveRF] = 0;
		wait1Msec(10);
	}//end if
	else// counterclockwise turn
	{
		motor[driveLR] = motor[driveLF] = -speed;
		motor[driveRR] = motor[driveRF] = speed;

		//loop to move the robot more slowly to its goal, also setting up a range
		//for the amount of acceptable error in the system
		while(SensorValue[gyro] > (target - error) || abs(SensorValue[gyro]) < (target + error))
		{
			if(SensorValue[gyro] > target)
			{
				motor[driveLR] = motor[driveLF] = -45;
				motor[driveRR] = motor[driveRF] = 45;
			}
			else
			{
				motor[driveLR] = motor[driveLF] = 45;
				motor[driveRR] = motor[driveRF] = -45;
			}
		}//end while
		//Stop
		motor[driveLR] = motor[driveLF] = 0;
		motor[driveRR] = motor[driveRF] = 0;
		wait1Msec(10);
	}//end else
}//end gyroturn function


/////////////////////////////////////
//
//   TURN LEFT BY DEGREE (ENCODER) function
//
/////////////////////////////////////

void turnleftdeg(int speed,int degrees)
{
	//Reset encoders
	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;

	//Determine # of pulses for target
	int target = (turnfactor * degrees) / 10;

	//Start the motors in a left point turn.
	motor[driveLF] = -speed;
	motor[driveLR] = -speed;
	motor[driveRF] = speed;
	motor[driveRR] = speed;

	while(SensorValue[encoderR] < target || SensorValue[encoderL] > -target)
	{
		if(SensorValue[encoderR] > target)
		{
			motor[driveRF] = 0;
			motor[driveRR] = 0;
		}
		if(SensorValue[encoderL] < -target)
		{
			motor[driveLF] = 0;
			motor[driveLR] = 0;
		}
	}
	//Make sure both motors stop at the end of the turn.
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn left by degree function


/////////////////////////////////
//
//     TURN LEFT BY TIME function
//
/////////////////////////////////

void turnlefttime(int speed,int timems) //clockwise turn
{
	//rotate left
	motor[driveLF] = -speed;
	motor[driveLR] = -speed;
	motor[driveRF] = speed;
	motor[driveRR] = speed;

	//wait time
	wait1Msec(timems);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn left by time function


///////////////////////////////////
//
// TURN RIGHT BY DEGREE (ENCODER) function
//
///////////////////////////////////

void turnrightdeg(int speed, int degrees)
{
	//Reset encoders
	SensorValue[encoderL] = 0;
	SensorValue[encoderR] = 0;


	//Determine target pulses
	int target = (turnfactor * degrees) / 10;

	//Start the motors in a right point turn.
	motor[driveLF] = speed;
	motor[driveLR] = speed;
	motor[driveRF] = -speed;
	motor[driveRR] = -speed;

	while(SensorValue[encoderL] < target || SensorValue[encoderR] > -target)
	{
		if(SensorValue[encoderL] > target)
		{
			motor[driveLF] = 0;
			motor[driveLR] = 0;
		}
		if(SensorValue[encoderR] < -target)
		{
			motor[driveRF] = 0;
			motor[driveRR] = 0;
		}
	}
	//Make sure both motors stop at the end of the turn.
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}// end turn right by degree function

/////////////////////////////////
//
//   TURN RIGHT BY TIME function
//
/////////////////////////////////

void turnrighttime(int speed,int timems) //counterclockwise turn
{
	//rotate right
	motor[driveLF] = speed;
	motor[driveLR] = speed;
	motor[driveRF] = -speed;
	motor[driveRR] = -speed;

	//wait time
	wait1Msec(timems);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveLR] = 0;
	motor[driveRF] = 0;
	motor[driveRR] = 0;

}//end turn right by time function


/////////////////////////////////
//
//     Scan LEFT for corner
//  scans with a left turn using the
//  ultrasonic to find the maximum
//  sensed distance
//
/////////////////////////////////
void scanleft()
{
	int currrdg;
	int lastrdg = SensorValue[frontsense];
	motor[driveLF] = motor[driveLR] = -50;
	motor[driveRF] = motor[driveRR] = 50;
	currrdg = SensorValue[frontsense];
	while (currrdg > lastrdg)
	{
		lastrdg = currrdg;
		wait1Msec(100);
		currrdg = SensorValue[frontsense];
	}
//	motor[driveLF] = motor[driveLR] = 50;
//	motor[driveRF] = motor[driveRR] = -50;
//	wait1Msec(200);
	motor[driveLF] = motor[driveLR] = 0;
	motor[driveRF] = motor[driveRR] = 0;

}


/////////////////////////////////
//
//     Scan RIGHT for corner
//  scans with a right turn using the
//  ultrasonic to find the maximum
//  sensed distance
//
/////////////////////////////////
void scanright()
{
	int currrdg;
	int lastrdg = SensorValue[frontsense];
	motor[driveLF] = motor[driveLR] = 50;
	motor[driveRF] = motor[driveRR] = -50;
	currrdg = SensorValue[frontsense];
	while (currrdg > lastrdg)
	{
		lastrdg = currrdg;
		wait1Msec(100);
		currrdg = SensorValue[frontsense];
	}
//	motor[driveLF] = motor[driveLR] = 50;
//	motor[driveRF] = motor[driveRR] = -50;
//	wait1Msec(200);
	motor[driveLF] = motor[driveLR] = 0;
	motor[driveRF] = motor[driveRR] = 0;

}



/////////////////////////////
//
//   	ARC LEFT FOR A DISTANCE
//
//      USEAGE:  arcleft (primary speed, speed difference [%], distance [in, right encoder])
//
/////////////////////////////
void arcleft(int speed, int diff, float dist)
{
	float target = (360/cir)*dist;//calculate encoder count for move
	int oppospeed = speed * ((100-diff)/100);//opposite speed is a percentage of primary speed
	SensorValue[encoderR] = 0;//reset right encoder

	if (dist>0)// moving forward
	{
		while(SensorValue[encoderR] < target-decel)
		{
			motor[driveRR] = motor[driveRF] = speed;//right side is faster
			motor[driveLR] = motor[driveLF] = oppospeed;//left side is slower
		}
		while (SensorValue[encoderR] < target)// move slow to final position
		{
			motor[driveRR] = motor[driveRF] = 50;
			motor[driveLR] = motor[driveLF] = 45;
		}
		// briefly reverse motors to brake
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = -40;
		//turn off motors
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 0;
	}

	else
	{
		while (SensorValue[encoderR] > target+decel)// moving backward
		{
			motor[driveRR] = motor[driveRF] = -speed;
			motor[driveLR] = motor[driveLF] = -oppospeed;
		}

		//while encoder is more than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderR] > target)
		{
			motor[driveRR] = motor[driveRF] = -50;
			motor[driveLR] = motor[driveLF] = -45;
		}
		// briefly reverse motors to brake
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 40;

		//turn off motors
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 0;
	}
}// end arcleft


/////////////////////////////
//
//   	ARC RIGHT FOR A DISTANCE
//
//      USEAGE:  arcright(primary speed, speed difference [%], distance [in, right encoder])
//
/////////////////////////////
void arcright(int speed, int diff, float dist)
{
	float target = (360/cir)*dist;//calculate encoder count for move
	int oppospeed = speed * ((100-diff)/100);//opposite speed is a percentage of primary speed
	SensorValue[encoderL] = 0;//reset left encoder

	if (dist>0)// moving forward
	{
		while(SensorValue[encoderL] < target-decel)
		{
			motor[driveRR] = motor[driveRF] = oppospeed;//right side is slower
			motor[driveLR] = motor[driveLF] = speed;//left side is faster
		}
		while (SensorValue[encoderL] < target)
		{
			motor[driveLR] = motor[driveLF] = 50;
			motor[driveRR] = motor[driveRF] = 45;
		}
		// briefly reverse motors to brake
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = -40;
		//turn off motors
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 0;
	}

	else
	{
		while (SensorValue[encoderL] > target+decel)// moving backward
		{
			motor[driveRR] = motor[driveRF] = -oppospeed;//right side is slower
			motor[driveLR] = motor[driveLF] = -speed;//left side is faster
		}

		//while encoder is less than target dist(counts), run at 50(slow to distance)
		while (SensorValue[encoderL] > target)
		{
			motor[driveLR] = motor[driveLF] = -50;
			motor[driveRR] = motor[driveRF] = -45;
		}
		// briefly reverse motors to brake
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 40;
		//turn off motors
		motor[driveLR] = motor[driveRR] = motor[driveLF] = motor[driveRF] = 0;
	}
}// end arcright

/////////////////////////////////
//
//   Left distance function
//   returns distance (mm) from leftsense
//   ultrasonic sensor
//
/////////////////////////////////
int leftdist()
{
	int dist;
	wait1Msec(1000);
	dist = SensorValue(leftsense);
	return dist;
}// end function leftdist

/////////////////////////////////
//
//   Right distance function
//   returns distance (mm) from rightsense
//   ultrasonic sensor
//
/////////////////////////////////
int rightdist()
{
	int dist;
	wait1Msec(1000);
	dist = SensorValue(rightsense);
	return dist;
}// end function rightdist

/////////////////////////////////
//
//   rear distance function
//   returns distance (mm) from rearsense
//   ultrasonic sensor
//
/////////////////////////////////
int frontdist()
{
	int dist;
	wait1Msec(1000);
	dist = SensorValue(frontsense);
	return dist;
}// end function rightdist


/////////////////////////////////
//
//   Lift for a time
//   positive speed = up
//   negative speed = down
//
/////////////////////////////////

void lifttime(int speed, int timems) // time based lift
{
	motor[liftLL] = speed;
	motor[liftLR] = speed;
	motor[liftUR] = speed;
	motor[liftUL] = speed;

	wait1Msec(timems);

	//	motor[liftLL] = 0;
	//	motor[liftLR] = 0;
	//	motor[liftRL] = 0;
	//	motor[liftRR] = 0;

}// end lift for time function


/////////////////////////////////
//
//   Grip for a time function
//   positive speed to close
//   negative speed to open
//
/////////////////////////////////

void griptime(int gspeed, int timems) // time based grip
{
	motor[grip] = gspeed;

	wait1Msec(timems);

	if (gspeed >0 )
	{
		motor[grip] = gripped;
	}
	else
	{
		motor[grip] = 0;
	}

}// end grip for time function

/////////////////////////////////
//
//   DRIVE and clamp function
//   drives for a short distance to blocks,
//   keeps moving while clamping
//   until it gets to a second distance
//   before stopping
//
/////////////////////////////////

void drivenclamp(int dspeed,float dist1,float dist2) //funtion for clamping when driving
{
	float target1 = (360/cir)*dist1; //calculate target encoder counts//

	float target2 = (360/cir)*dist2; //calculate target encoder counts/

	SensorValue[encoderL] = 0; //reset encoder count to zero//

	while (SensorValue[encoderL] < target1)
	{
		motor[driveLF] = dspeed;
		motor[driveLR] = dspeed;
		motor[driveRF] = dspeed;
		motor[driveRR] = dspeed;
	}
	griptime(90,300);

	while (SensorValue[encoderL] < target2)
	{
		motor[driveLF] = dspeed;
		motor[driveLR] = dspeed;
		motor[driveRF] = dspeed;
		motor[driveRR] = dspeed;
	}


	//while encoder is less than target dist(counts), run at 50(slow to distance)
	while (SensorValue[encoderL] < target2)
	{
		motor[driveLF] = 50;
		motor[driveRF] = 50;
		motor[driveLR] = 50;
		motor[driveRR] = 50;
	}

	// briefly reverse motors to brake
	motor[driveLF] = -50;
	motor[driveRF] = -50;
	motor[driveLR] = -50;
	motor[driveRR] = -50;
	wait1Msec(pause);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveRF] = 0;
	motor[driveLR] = 0;
	motor[driveRR] = 0;
}// end drivenclamp function


/////////////////////////////////
//
//   DRIVE and lift function
//   drives for a short distance to goal,
//   keeps moving while lifting
//   until it gets to a second distance
//   before stopping
//
/////////////////////////////////

void drivenlift(int dspeed,float dist) //function for lifting when driving into corner
{
	float target1 = (360/cir)*(dist-11); //calculate target encoder counts//

	float target2 = (360/cir)*dist; //calculate target encoder counts/

	SensorValue[encoderL] = 0; //reset encoder count to zero//

	while (SensorValue[encoderL] < target1)
	{
		motor[driveLF] = dspeed;
		motor[driveLR] = dspeed;
		motor[driveRF] = dspeed;
		motor[driveRR] = dspeed;
	}
	liftrequest = offgoal;

	while (SensorValue[encoderL] < target2)
	{
		motor[driveLF] = dspeed;
		motor[driveLR] = dspeed;
		motor[driveRF] = dspeed;
		motor[driveRR] = dspeed;
	}
	// briefly reverse motors to brake
	motor[driveLF] = -50;
	motor[driveRF] = -50;
	motor[driveLR] = -50;
	motor[driveRR] = -50;
	wait1Msec(pause);

	//turn off motors
	motor[driveLF] = 0;
	motor[driveRF] = 0;
	motor[driveLR] = 0;
	motor[driveRR] = 0;

}//end drivenlift

/////////////////////////////////
//
//   Gyro Setup and calibration
//   3 second routin to clear and
//   calibrate the gyro
//
/////////////////////////////////

void gyrocal()
{
	SensorType[gyro] = sensorNone;
	wait1Msec(1000);
	SensorType[gyro] = sensorGyro;
	wait1Msec(2000);
	SensorScale[gyro] = 98;
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//                          AUTONOMOUS ROUTINES
//                      (FOR EACH PART OF THE FIELD
//                          OR FOR SKILLS)
//
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//+++++++++++++++++++++++++++++++
//
// Blue Large goal
// Auton for blue side, by the large goal
//
//+++++++++++++++++++++++++++++++
void blue_lrg()
{
	liftrequest = field;
	strafe(127,-8);// strafe in preload
	drivenclamp(120,12,30);// drive and get 1st single cube
	liftrequest = lowcup;//raise arm
	turnleftdeg(80,30);//turn towards cup
	drive(120,22);
	griptime(-70,250);//drop in low cup
	drive(100,-11);// back away from cup
	wait1Msec(200);
	turnleftdeg(70,63);// rotate to stack of 4
	liftrequest = field;
	wait1Msec(400);
	drivenclamp(50,6,13);//pickup stack of 4
	wait1Msec(200);
	turnleftdeg(90,160);//head to corner
	drivenlift(127,42.5);
	griptime(-50,200);//drop in corner
	liftrequest = offfield;
	drive(120,-9);

}//end blue_lrg


//+++++++++++++++++++++++++++++++
//
//  blue small
//  auton program for blue side by small goal
//
//+++++++++++++++++++++++++++++++
void blue_sm()
{
	liftrequest = field;//lower arm to field
	strafe(127,9);//strafe to put in preload
	strafe(127,-9);//strafe back
	drive(127,12);//drive to low cup
	griptime(127,250);//grab cube
	liftrequest = lowcup;
	turnleftdeg(100,60);
	drive(100,16);//drive to cup
	griptime(-90,200);//release cube
	liftrequest = field;
	drive(100,-15);//backup
	turnrightdeg(100,151);//turn left to mid cup
	drive(100,24);//drive to cup
	griptime(90,200);//pickup cube
	liftrequest = offgoal;
	drive(100,-8);//backup
	liftrequest = midcup;//raise arm
	wait1Msec(800);//wait for arm
	drive(100,13);//drive to cup
	griptime(-90,200);//release cube
	liftrequest = field;
	drive(100,-10);//backup up to clear

}// end blue_sm



//+++++++++++++++++++++++++++++++
//
//  Red large part 1
//  start through strafe to stack of 3
//
//+++++++++++++++++++++++++++++++
void red_l1()
{
	liftrequest = field;
	strafe(127,8);// strafe in preload
	drivenclamp(120,12,30);// drive and get 1st single cube
	liftrequest = lowcup;//raise arm
	turnrightdeg(80,18);//turn towards cup
	drive(120,22);
	griptime(-70,200);//drop in low cup
	drive(100,-11);// back away from cup
	wait1Msec(200);
	turnrightdeg(70,63);// rotate to stack of 4
	liftrequest = field;
	wait1Msec(900);
	drivenclamp(50,6,13);//pickup stack of 4
	wait1Msec(200);
	turnrightdeg(90,155);//head to red corner
	drivenlift(127,42.5);
	griptime(-50,200);//drop in corner
	liftrequest = offfield;
	drive(120,-9);
	turnleftdeg(120,130);//turn to pickup and drop in mid cup
	liftrequest = field;
	drivenclamp(80,14,20);//pick up next single cube
	liftrequest = midcup;// raise arm
	wait1Msec(500);
	drive(120,17);
	griptime(-50,150);//drop in mid cup
	drive(120,-12);// back away
	liftrequest = field;
	wait1Msec(900);
	strafe(80,34);//strafe to stack of 3

}
// end red _l1


//+++++++++++++++++++++++++++++++
//
//  red large part 2
//  pick up stack of 3 through stop in front of small goal
//
//+++++++++++++++++++++++++++++++
void red_l2()
{
	drivenclamp(70,17,22);//Pickup stack of 3
	turnrightdeg(90,48);
	drive(120,35);//drive at corner
	turnleftdeg(70,56);
	drive(90,28);
	turnrightdeg(90,19);

}// end red 2

//+++++++++++++++++++++++++++++++
//
//  Red lrg 3
//  fill small goal thru final cups
//
//+++++++++++++++++++++++++++++++
void red_l3()
{
	griptime(90,50);
	drive(100,14);//finish drive to corner
	griptime(-72,180);
	liftrequest = offfield;
	drive(80,-8);//back off corner
	turnleftdeg(90,130);//turn to row of 4
	liftrequest=field;
	wait1Msec(500);//wait for lift
	drive(80,10);
	griptime(60,200);
	turnrightdeg(80,66);//turn to red cup
	liftrequest = lowcup;
	wait1Msec(300);
	drive(80,10);//drive to red cup
	griptime(-50,200);
	drive(80,-5);//back off red cup
	liftrequest = field;
	drive(80,-10);
	turnleftdeg(80,55);//turn to row of cubes
	drive(80,10);
	griptime(60,200);//clamp another cube
	turnleftdeg(60,29);
	liftrequest = lowcup;
	drive(90,22);//drive to low cup
	griptime(-60,180);//release low cup
	drive(90,-10);//back off low cup
	liftrequest = field;//lower to field
	wait1Msec(700);//wait for arm
	turnleftdeg(90,60);
	drive(90,13);//drive to 2 stack
	griptime(90,300);
	turnrightdeg(90,22);//turn toward high cup
	liftrequest = highcup;
	wait1Msec(600);//wait for lift
	drive(80,23);//drive to high stack
	griptime(-80,200);//release cube
	drive(90,-10);//back off high cup
	liftrequest = field;
	wait1Msec(500);
	turnrightdeg(90,43);//head to blue 2 stack
	drivenclamp(90,22,31);//drive and clamp two cubes from blue side
	liftrequest = midcup;//raise arm
	turnleftdeg(90,38);//turn to mid cup on blue
	drive(90,28);//drive to mid
	griptime(-90,100);//release cube
	drive(90,-10);//back off mid cup
}// end red l3


//+++++++++++++++++++++++++++++++
//
//  Prog Skills part 2 large goal end
//  pick up stack of 3 and bring it to large blue goal
//
//+++++++++++++++++++++++++++++++
void progP2()
{
	liftrequest = field;//arm down
	drivenclamp(60,18,22);//Pickup stack of 3
	turnrightdeg(90,200);//turn 180
	drive(120,48);//drive at wall
	turnrightdeg(90,90);//turn to blue goal
	drive(90,62);//drive to blue goal
	turnleftdeg(90,20);//final turn to goal
}// end prog skills part 2



//+++++++++++++++++++++++++++++++
//
//  Prog Skills part 3 large goal end
//  pick up stack of 3 and bring it to large blue goal
//
//+++++++++++++++++++++++++++++++
void progP3()
{
	griptime(80,150);
	wait1Msec(200);
	liftrequest = offgoal;
	drive(70,13);//drive into goal
	griptime(-80,180);//release cubes
	liftrequest = offfield;
	drive(120,-9);//drive out of goal
	turnrightdeg(120,105);//turn toward cube for mid tower
	liftrequest = field;//arm to field
	drivenclamp(90,18,24);//pick up cube
	liftrequest = midcup;//raise arm
	wait1Msec(500);
	drive(120,17);//drive to mid tower
	griptime(-60,200);//release cube
	drive(120,-14);//backup from tower
	liftrequest = field;//arm down
	turnrightdeg(90,93);//turn toward 4 stack
	drivenclamp(70,17,22);//grab 4 stack
	turnrightdeg(90,140);//turn toward goal
	drive(90,28);//drive to goal
	turnrightdeg(90,25);//final turn to goal
	liftrequest = offgoal;//raise arm
	drive(50,20);// drive into goal
	griptime(-60,180);//release cubes
	drive(90,-10);//backup
	turnleftdeg(90,190);//turn to cube
	drivenclamp(90,30,40);//pick up cube
	turnrightdeg(90,10);//turn to high cup
	liftrequest = highcup;
	drive(80,15);//drive to high cup
	griptime(-60,180);//release cube
	drive(80,-5);//back up from cup


}


//+++++++++++++++++++++++++++++++
//
//  red small
//  auton for red side, small goal end
//
//+++++++++++++++++++++++++++++++
void red_sm()
{
	liftrequest = field;//lower arm to field
	strafe(127,-8);//strafe to put in preload
	strafe(127,8);//strafe back
	drive(127,12);//drive to low cup
	griptime(127,250);//grab cube
	liftrequest = lowcup;
	turnrightdeg(100,50);
	drive(100,16);//drive to cup
	griptime(-90,200);//release cube
	liftrequest = field;
	drive(100,-15);//backup
	turnleftdeg(100,151);//turn left to mid cup
	drive(100,24);//drive to cup
	griptime(90,200);//pickup cube
	liftrequest = offgoal;
	drive(100,-8);//backup
	liftrequest = midcup;//raise arm
	wait1Msec(800);//wait for arm
	drive(100,13);//drive to cup
	griptime(-90,200);//release cube
	liftrequest = field;
	drive(100,-10);//backup up to clear

}// end red sm


//+++++++++++++++++++++++++++++++
//
//   No Auton - Just in case
//
//+++++++++++++++++++++++++++++++
void NoAuton()
{
	drive2(60,90);
	wait1Msec(3000);
	drive2(60,-90);

}//end of No Auton


//************************************
//
//   lift PID control task
//
//************************************


task liftPIDctrl()
{
	float  liftcurrentvalue; // placeholder for current value of lift
	float  lifterror; // error between current and desired position
	float  liftdrive; // command to drive based on error
	float  liftinteg = 0; // integral portion
	float  liftderiv = 0; // derivative portion
	float  lastlifterr = 0;// last error

	while(1==1)
	{
		while(liftrequest > 1)
		{
			// Read the current position from the lift sensor
			liftcurrentvalue = SensorValue[liftpos];// value from pot on lift

			// calculate position error and PID parts
			lifterror =  liftrequest - liftcurrentvalue;// error between desired and actual lift position

			liftinteg = liftinteg + lifterror;// integral, long term, accumulated error
			if (lifterror == 0 | fabs(liftinteg) > liftIlimit)
				liftinteg = 0;// set limits on integral so it doesn't run away and cause swings

			liftderiv = lifterror - lastlifterr;// derivative short term, how fast is it closing in on request
			lastlifterr = lifterror;// store the last error for the next calculation for D number

			// calculate motor power based on error value and PID constants
			liftdrive = (lift_P * lifterror) + (lift_I * liftinteg) + (lift_D * liftderiv) + liftbias;

			// limit motor power so motion is controlled
			if( liftdrive > 80 )
				liftdrive = 80;
			if( liftdrive < (-30) )
				liftdrive = (-30);

			// send power to the lift motors
			motor[liftLL] = liftdrive;
			motor[liftLR] = liftdrive;
			motor[liftUL] = liftdrive;
			motor[liftUR] = liftdrive;
			// add PID items to datalog

			// Don't hog cpu
		}
		wait1Msec(10);
	}// end constant while
}//end lift PID



//************************************
//
//   Competition Timer task
//
//************************************

task comptimer()
{
	int tmrreset = 0;//tracker for if the match has started
	while(1==1)
	{
		if (SensorValue[driverskill] == false)
		{
			matchtime = 60000;// 60 second skills match
		}
		else
		{
			matchtime = 105000;//minute 45 second comp match
		}
		if(bIfiAutonomousMode == false & bIfiRobotDisabled == false & tmrreset == 0)
		{
			clearTimer(T1);//clear match timer
			tmrreset = 1;//mark that the match has started
		}
		if (time1[T1] > (matchtime-buzz1) & time1[T1] < (matchtime-buzz2))//alert that match end is close
		{
			playSound(soundBeepBeep);// initial beep for alarm at 1st time
		}
		if (time1[T1] > (matchtime-buzz2) & time1[T1] < matchtime)//5 second warning!!
		{
			playSound(soundFastUpwardTones);// secondary beep for warning at 2nd time
		}
	}//end while loop
}//end comptimer task


//////////////////////////////////////////////////////////////////////////
//
//                          PRE-AUTONOMOUS FUNCTIONS
//                   Menu selection to pick individual autons
//
//////////////////////////////////////////////////////////////////////////
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	bDisplayCompetitionStatusOnLcd = false;

	//Turns on the Backlight
	bLCDBacklight = true;


	// setup gyro
	displayLCDCenteredString (0, "Calibrating Gyro");
	displayLCDCenteredString (1, "DONT MOVE ROBOT!");
	gyrocal();
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString (0, "Calibration");
	displayLCDCenteredString (1, "Complete");
	wait1Msec(1000);

	// Leave this value alone; counting starts at 1
	int lcdScreenMin = 1;

	//  IMPORTANT!!!
	// Total # menu items ***** Note Adjust this to match your number of programs!!!
	int lcdScreenMax = 7;

	// Counter for what to display on the screen
	int lcdScreen = 1;

	//Turns on the Backlight
	bLCDBacklight = true;

	// Leave these values alone
	// In RobotC:
	// when the left button is pressed, nLCDButtons = 1
	// when middle button is pressed, nLCDButtons = 2
	// when right button is pressed, nLCDButtons = 4
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;



	// This main loop will run as long at the competition
	// switch is set to ?Disabled?; When the system is
	// set to ?Enable? this loop will automatically stop.
	while (bIfiRobotDisabled == 1) {

		// This section checks whether left & right buttons are
		// pressed, and either increments or decrements the
		// lcdScreen counter; if the counter is at the max or min
		// it will loop around to the other end

		// left button
		if (nLCDButtons == leftButton) {
			if (lcdScreenMin == lcdScreen) {
				lcdScreen = lcdScreenMax;
				wait1Msec(250);
			}
			else {
				lcdScreen= lcdScreen-1;
				wait1Msec(250);
			}
		}

		// right button
		if (nLCDButtons == rightButton) {
			if (lcdScreenMax == lcdScreen) {
				lcdScreen = lcdScreenMin;
				wait1Msec(250);
			}
			else {
				lcdScreen=lcdScreen+1;
				wait1Msec(250);
			}
		}

		// The rest of pre-auton checks to see whether the middle
		// button is pressed

		// Each menu item below has 2 blocks of code, depending on
		// whether you've already selected this option, or not

		// If you have not already selected this option as
		// your choice, it will display the text normally, and will
		// then check to see if you're pressing the middle button.

		//------------------------------------------------------------//
		if (lcdScreen == 1 && autonProgram != 1) {
			displayLCDCenteredString (0, "Red Large");
			displayLCDCenteredString (1, "Large Goal");

			// When you press the middle button, the screen says,
			// Blah blah is selected! for 1.5 seconds
			// and also sets the autonProgram variable
			if (nLCDButtons == centerButton) {
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Red Large");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		// If you have already selected this item, the menu
		// text will have [square brackets] around it
		// to indicate that this is the option you've chosen.
		else if (lcdScreen == 1 && autonProgram == 1) {
			displayLCDCenteredString (0, "[Red Large]");
			displayLCDCenteredString (1, "[Large Goal]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 2 && autonProgram != 2) {
			displayLCDCenteredString (0, "Red Small");
			displayLCDCenteredString (1, "Small Goal");

			if (nLCDButtons == centerButton) {
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Red Small");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 2 && autonProgram == 2) {
			displayLCDCenteredString (0, "[Red Small]");
			displayLCDCenteredString (1, "[Small Goal]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 3 && autonProgram != 3)
		{
			displayLCDCenteredString (0, "Blue Large");
			displayLCDCenteredString (1, "Large Goal");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Blue Large");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 3 && autonProgram == 3) {
			displayLCDCenteredString (0, "[Blue Large]");
			displayLCDCenteredString (1, "[Large Goal]");
		}
		//------------------------------------------------------------//
		else if (lcdScreen == 4 && autonProgram != 4) {
			displayLCDCenteredString (0, "Blue Small");
			displayLCDCenteredString (1, "Small Goal");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Blue Small");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 4 && autonProgram == 4)
		{
			displayLCDCenteredString (0, "[Blue Small]");
			displayLCDCenteredString (1, "[Small Goal]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 5 && autonProgram != 5)
		{
			displayLCDCenteredString (0,"Prg Skl Lg End");
			displayLCDCenteredString (1, "Strt @ Red Lrg");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Prg Skl Lg End");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 5 && autonProgram == 5) {
			displayLCDCenteredString (0, "[Prg Skl Lg End]");
			displayLCDCenteredString (1, "[Strt @ Red Lrg]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 6 && autonProgram != 6)
		{
			displayLCDCenteredString (0,"Prg Skl Red Sd");
			displayLCDCenteredString (1, "Strt @ Red Lrg");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "Prg Skl Red Sd");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 6 && autonProgram == 6) {
			displayLCDCenteredString (0, "[Prg Skl Red Sd]");
			displayLCDCenteredString (1, "[Strt @ Red Lrg]");
		}
		//------------------------------------------------------------------//
		else if (lcdScreen == 7 && autonProgram != 7)
		{
			displayLCDCenteredString (0,"No Auton");
			displayLCDCenteredString (1, "Does Nothing");

			if (nLCDButtons == centerButton)
			{
				autonProgram = lcdScreen;
				displayLCDCenteredString (0, "No Auton");
				displayLCDCenteredString (1, "is selected!");
				clearSounds();
				wait1Msec(1500);
			}
		}

		else if (lcdScreen == 7 && autonProgram == 7) {
			displayLCDCenteredString (0, "[No Auton]");
			displayLCDCenteredString (1, "[Does Nothing]");
		}
		//------------------------------------------------------------------//



		// if no atonomous is seldcted (autonProgram is still default value), play beep sound
		if (autonProgram == 99)
		{
			playSound(soundBeepBeep);
			wait1Msec(400);
		}

	}	// end of while-disabled loop
}// end of pre-auton



//*************************************************************************
//
//                          MAIN AUTONOMOUS TASK
//                   THIS RUNS THE CORRECT AUTONOMOUS ROUTINE
//                   BASED ON THE ITEM SELECTED IN THE PRE-AUTON MENU
//                   (value of _autonProgram_ variable)
//
//*************************************************************************
task autonomous()//This is the begining of the Autonomous Code
{
	// start PID task at current value of lift when field is enabled
	liftrequest = field;
	startTask(liftPIDctrl);


	if (autonProgram == 1)
	{
		red_l1();//red large goal routine
	}
	else if (autonProgram == 2)
	{
		red_sm();//red small goal routine
	}
	else if (autonProgram == 3)
	{
		blue_lrg();//blue large goal routine
	}
	else if (autonProgram == 4)
	{
		blue_sm();//blue small goal routine
	}
	else if (autonProgram == 5)
	{
		red_l1();//part 1 is red large goal routine
		progP2();//part 2 is large goal side skills routine
	}
	else if (autonProgram == 6)
	{
		red_l1();//part 1 is red large goal routine
		red_l2();//part 2 is red large goal part 2 routine
		red_l3();//part 2 is red large goal part 3 routine
	}
	else if ((autonProgram == 7) || (autonProgram == 99))
	{
		NoAuton();//do nothing auton program
	}

}//End of Autonomous



//*************************************************************************
//                                                                        *
//             INDIVDUAL TASKS FOR EACH DRIVER CONTROL OPTION             *
//       Driver control is multitasking.  Each major function on the      *
//           robot has its own task based on its joystick control         *
//               or its function in the driver control portion            *
//*************************************************************************
//************************************************************
//
//             driver screen task
//          screen to display battery voltage and
//           sensor values when in drive control mode
//
//***********************************************************

task driverscreen()//  display items on the screen to allow for diagnosis
{
	// Leave this value alone; counting starts at 1
	int driverScreenMin = 1;

	//  IMPORTANT!!!
	// Total # menu items ***** Note Adjust this to match your number of screens!!!
	int driverScreenMax = 9;

	// Counter for what to display on the screen
	int driverScreen = 1;

	//Turns on the Backlight
	bLCDBacklight = true;

	// Leave these values alone
	// In RobotC:
	// when the left button is pressed, nLCDButtons = 1
	// when middle button is pressed, nLCDButtons = 2
	// when right button is pressed, nLCDButtons = 4
	const short leftButton = 1;
	const short centerButton = 2;
	const short rightButton = 4;

	string mainBattery, expBattery, lencdist, rencdist, liftpotdist, gyroang,lusonic, rusonic, rrusonic;


	// This section checks whether left & right buttons are
	// pressed, and either increments or decrements the
	// lcdScreen counter; if the counter is at the max or min
	// it will loop around to the other end
	while(1==1)
	{
		// left button
		if (nLCDButtons == leftButton) {
			if (driverScreenMin == driverScreen) {
				driverScreen = driverScreenMax;
				wait1Msec(250);
			}
			else {
				driverScreen= driverScreen-1;
				wait1Msec(250);
			}
		}

		// right button
		if (nLCDButtons == rightButton) {
			if (driverScreenMax == driverScreen) {
				driverScreen = driverScreenMin;
				wait1Msec(250);
			}
			else {
				driverScreen=driverScreen+1;
				wait1Msec(250);
			}
		}

		//------------------------------------------------------------
		if (driverScreen == 1) {
			clearLCDLine(0);
			clearLCDLine(1);

			//Display the Primary Robot battery voltage
			displayLCDString(0, 0, "MBat: ");
			sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
			displayNextLCDString(mainBattery);

			//Display the Backup battery voltage
			displayLCDString(1, 0, "EBat: ");
			sprintf(expBattery, "%1.2f%c", SensorValue(expBatt)/280.0, 'V');	//Build the value to be displayed
			displayNextLCDString(expBattery);

			//Short delay for the LCD refresh rate
			wait1Msec(100);
		}
		//------------------------------------------------------------
		else if (driverScreen == 2 ) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "LEnc: ");
			displayNextLCDNumber(SensorValue(encoderL));
			displayLCDString (1, 0, "REnc: ");
			displayNextLCDNumber(SensorValue(encoderR));
			wait1Msec(100);
		}
		//------------------------------------------------------------
		else if (driverScreen == 3) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "LEnc: ");
			displayNextLCDNumber(SensorValue(encoderL));
			displayLCDString (1, 0, "Dist: ");
			sprintf(lencdist, "%3.2f", SensorValue(encoderL)*cir/360);
			displayNextLCDString(lencdist);

			if (nLCDButtons == centerButton) {
				SensorValue(encoderL) = 0;
				SensorValue(encoderR) = 0;
			}
			wait1Msec(100);
		}
		//------------------------------------------------------------
		else if (driverScreen == 4) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "REnc: ");
			displayNextLCDNumber(SensorValue(encoderR));
			displayLCDString (1, 0, "Dist: ");
			sprintf(rencdist, "%3.2f", SensorValue(encoderR)*cir/360);
			displayNextLCDString(rencdist);

			if (nLCDButtons == centerButton) {
				SensorValue(encoderL) = 0;
				SensorValue(encoderR) = 0;
			}
			wait1Msec(100);
		}

		//------------------------------------------------------------
		else if (driverScreen == 5) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDString (0, 0, "Liftpot: ");
			displayNextLCDNumber(SensorValue(liftpos));
			wait1Msec(100);
		}

		//------------------------------------------------------------
		else if (driverScreen == 6) {
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDCenteredString (0, "Gyro");
			sprintf(gyroang, "%3.1f", (SensorValue(gyro)/10));
			displayLCDCenteredString (1, gyroang);
			wait1Msec(100);
			if (nLCDButtons == centerButton) {
				displayLCDCenteredString (0, "Calibrating Gyro");
				displayLCDCenteredString (1, "DONT MOVE ROBOT!");
				gyrocal();
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString (0, "Calibration");
				displayLCDCenteredString (1, "Complete");
				wait1Msec(1000);
			}

}
			//------------------------------------------------------------
			else if (driverScreen == 7) {
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString (0, "Left Ultrasonic");
				sprintf(lusonic, "%3.2f", SensorValue(leftsense));
				displayLCDCenteredString (1, lusonic);
				wait1Msec(100);
			}
			//------------------------------------------------------------
			else if (driverScreen == 8) {
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString (0, "Right Ultrasonic");
				sprintf(rusonic, "%3.2f", SensorValue(rightsense));
				displayLCDCenteredString (1, rusonic);
				wait1Msec(100);
			}

			//------------------------------------------------------------
			else if (driverScreen == 9) {
				clearLCDLine(0);
				clearLCDLine(1);
				displayLCDCenteredString (0, "Front Ultrasonic");
				sprintf(rrusonic, "%3.2f", SensorValue(frontsense));
				displayLCDCenteredString (1, rrusonic);
				wait1Msec(100);
			}

			//------------------------------------------------------------
			wait1Msec(10);
		}// end while loop for screen
	} // end driver screen



	//*******************************************************************
	//
	//                                 Lift Control Task
	//
	//*******************************************************************
	task liftcontrol()
	{
		while (1==1)
		{
			// automatic controlled lift positions for preset heights set to buttons on joystick
			if (vexRT[Btn7U] == 1)// preset position for high cup load
			{
				liftrequest = highcup;
			}
			else if (vexRT[Btn7R] == 1)// preset position for middle cup load
			{
				liftrequest = midcup;
			}
			else if (vexRT[Btn7L] == 1)//preset position for low cup load
			{
				liftrequest = lowcup;
			}
			else if (vexRT[Btn7D] == 1)// preset position for field (lowest)
			{
				liftrequest = field;
			}
			else if (vexRT[Btn8L] == 1)//preset position for just off field for driving
			{
				liftrequest = offfield;
			}
			// manual controlled lift positions for raising and lowering lift from buttons on joystick
			if (vexRT[Btn8U] == 1 | vexRT[Btn8D] == 1)
			{
				liftrequest = -1;
				manual = 1;
				int liftup = 0; //1 = up, 0 = down
				int lifthold = 25; //motor speed to hold lift up

				if (vexRT[Btn8U] == 1 & vexRT[Btn8D] == 0 & SensorValue(lifthigh) == 0 ) // up button pressed, down not, and lift not raised
				{
					motor[liftLL] = 70;
					motor[liftLR] = 70;
					motor[liftUL] = 70;
					motor[liftUR] = 70;
					liftup = 1;
				}

				else if (vexRT[Btn8U] == 1 & vexRT[Btn8D] == 0 & SensorValue(lifthigh) == 1 ) // up button pressed,down not, and lift fully raised
				{
					motor[liftLL] = lifthold;
					motor[liftLR] = lifthold;
					motor[liftUL] = lifthold;
					motor[liftUR] = lifthold;
					liftup = 1;
				}


				else if (vexRT[Btn8U] == 0 & vexRT[Btn8D] == 1)//  down button pressed, up not
				{
					motor[liftLL] = -20;
					motor[liftLR] = -20;
					motor[liftUL] = -20;
					motor[liftUR] = -20;
					liftup = 0;
				}
			}
			else // last case where neither button is pressed, or both are pressed (want to be either stopped or not going both directions)
			{
				if (manual == 1)
				{
					liftrequest = SensorValue(liftpos)-20;
					manual = 0;
				}
			}
			wait1Msec(10);
		}//end while
	}// end of lift control task



	//*******************************************************************
	//
	//                                 Grip Control Task
	//
	//*******************************************************************
	task gripcontrol()

	{
		int gripstate = 1; //1 = open, 0 = closed.
		while (1==1)

		if (vexRT[Btn5D] == 1 & vexRT[Btn5U] == 0) // open (D) button pressed, close (U) not
		{
			motor[grip] = -55;
			gripstate = 1;
		}

		else if (vexRT[Btn5D] == 0 & vexRT[Btn5U] == 1)//  close (U) button pressed, open (D) not
		{
			motor[grip] = 80;
			gripstate = 0;

		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[grip] = 80;
			gripstate = 0;
			wait1Msec(500);
			liftrequest = offfield;
		}
		else// last case where neither button is pressed, or both are pressed (want to be either stopped or not going both directions)
		{
			if (gripstate == 1) // gripper open
			{
				motor[grip] = 0;
			}
			else  // gripper open
			{
				motor[grip] = gripped; // some power to keep gripped
			}
			wait1Msec(10);// dont hog the processor
		}

	}// end of grip control task


	//*******************************************************************
	//
	//                                 User Control Task
	//
	// This task is used to control the robot during the user control phase of a VEX Competition.
	// You must modify the code to add your own robot specific commands here.
	//
	//*******************************************************************
	task usercontrol()
	{
		//Start other user/driver tasks to run the robot
		startTask(driverscreen); // task to run driver screen for voltage and sensor value displays
		startTask(liftcontrol); //task to run lift control based on joystick button inputs
		startTask(gripcontrol); //task to open/close grippers based on joystick buttons
		startTask(comptimer);// task to sound speaker at the end of the competition
		liftrequest = SensorValue(liftpos);//sets inital position for lift at current position of potentiometer sensor
		startTask(liftPIDctrl);// starts lift pid control task to handle arm positions based on potentiometer sensor


		int rf;
		int rr;
		int lf;
		int lr;

		while (1==1)
			/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*                         Chassis Control                                */
		/*                  This is used to control our chassis                   */
		/*                                                                        */
		/*------------------------------------------------------------------------*/
		{
			// if driverskills button is pressed, run skills macro task control
			if ((vexRT[Btn7UXmtr2] == 1) & (skilltrack == 0))// 7U pressed and none run before
			{
				stopTask(gripcontrol);
				red_l1();
				skilltrack = 1;// increase tracker to show part 1 has run
				startTask(gripcontrol);
			}
			if ((vexRT[Btn7RXmtr2] == 1) & (skilltrack == 1))// 7R pressed and part 1 run already
			{
				stopTask(gripcontrol);
				red_l2();
				skilltrack = 2;// increase tracker to show part 2 has run
				startTask(gripcontrol);
			}
			if ((vexRT[Btn7DXmtr2] == 1) & (skilltrack == 2))// 7D pressed and part 2 run already
			{
				stopTask(gripcontrol);
				red_l3();
				skilltrack = 3;
				startTask(gripcontrol);
			}
			// if driverskills button is pressed, run skills macro task control
			if ((vexRT[Btn8UXmtr2] == 1) & (skilltrack == 0))// 7U pressed and none run before
			{
				stopTask(gripcontrol);
				red_l1();
				skilltrack = 1;// increase tracker to show part 1 has run
				startTask(gripcontrol);
			}
			if ((vexRT[Btn8RXmtr2] == 1) & (skilltrack == 1))// 7R pressed and part 1 run already
			{
				stopTask(gripcontrol);
				progP2();
				skilltrack = 22;// increase tracker to show part 2 has run
				startTask(gripcontrol);
			}
			if ((vexRT[Btn8DXmtr2] == 1) & (skilltrack == 22))// 7D pressed and part 2 run already
			{
				stopTask(gripcontrol);
				progP3();
				skilltrack = 23;
				startTask(gripcontrol);
			}



			//Create "deadzone" for Y1/Ch3 Forward and backwards movement
			if(abs(vexRT[Ch3]) > threshold)
				Y1 = vexRT[Ch3];
			else
				Y1 = 0;
			//Create "deadzone" for X1/Ch4 Strafing
			if(abs(vexRT[Ch4]) > threshold)
				X1 = vexRT[Ch4];
			else
				X1 = 0;
			//Create "deadzone" for X2/Ch1 Turning
			if(abs(vexRT[Ch1]) > threshold)
				X2 = vexRT[Ch1];
			else
				X2 = 0;


			//filter motor speed to maximum value in global variables
			rf = Y1 - X2 - X1; //right front motor speed
			if (rf > maxspeed) //limit right front motor speed to maxspeed
				rf = maxspeed;

			rr = Y1 - X2 + X1; // right rear motor speed
			if (rr > maxspeed) // limit right rear motor speed to maxspeed
				rr = maxspeed;

			lf = Y1 + X2 + X1; // left front motor speed
			if (lf > maxspeed) // limit left front motor speed
				lf = maxspeed;

			lr = Y1 + X2 - X1; // left rear motor speed
			if (lr > maxspeed) // limit left rear motor speed
				lr = maxspeed;

			// if slow button is pressed, slow motors for accuracy and control
			if (vexRT[Btn6U] == 1)
			{
				rf = rf * drivescale;
				rr = rr * drivescale;
				lf = lf * drivescale;
				lr = lr * drivescale;
			}

			// set motor speeds to motors
			motor[driveRF] = rf;
			motor[driveRR] = rr;
			motor[driveLF] = lf;
			motor[driveLR] = lr;
			wait1Msec(10);// don't hog the processor
		} // end driver while loop
	} //End of user control
